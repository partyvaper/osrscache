#include "InterfaceManager.h"
#include "IndexType.h"

namespace net::runelite::cache
{
	using File = java::io::File;
	using IOException = java::io::IOException;
	using PrintWriter = java::io::PrintWriter;
	using InterfaceDefinition = net::runelite::cache::definitions::InterfaceDefinition;
	using InterfaceExporter = net::runelite::cache::definitions::exporters::InterfaceExporter;
	using InterfaceLoader = net::runelite::cache::definitions::loaders::InterfaceLoader;
	using Archive = net::runelite::cache::fs::Archive;
	using ArchiveFiles = net::runelite::cache::fs::ArchiveFiles;
	using FSFile = net::runelite::cache::fs::FSFile;
	using Index = net::runelite::cache::fs::Index;
	using Storage = net::runelite::cache::fs::Storage;
	using Store = net::runelite::cache::fs::Store;
	using Namer = net::runelite::cache::util::Namer;

	InterfaceManager::InterfaceManager(std::shared_ptr<Store> store) : store(store)
	{
	}

	void InterfaceManager::load()
	{
		std::shared_ptr<InterfaceLoader> loader = std::make_shared<InterfaceLoader>();

		std::shared_ptr<Storage> storage = store->getStorage();
		std::shared_ptr<Index> index = store->getIndex(IndexType::INTERFACES);

		int max = index->getArchives().stream().mapToInt([&] (std::any a)
		{
		a::getArchiveId();
		}).max().getAsInt();
		interfaces = std::vector<std::vector<std::shared_ptr<InterfaceDefinition>>>(max + 1);

		for (auto archive : index->getArchives())
		{
			int archiveId = archive->getArchiveId();
			std::vector<signed char> archiveData = storage->loadArchive(archive);
			std::shared_ptr<ArchiveFiles> files = archive->getFiles(archiveData);

			std::vector<std::shared_ptr<InterfaceDefinition>> ifaces = interfaces[archiveId];
			if (ifaces.empty())
			{
				ifaces = interfaces[archiveId] = std::vector<std::shared_ptr<InterfaceDefinition>>(archive->getFileData().size());
			}

			for (auto file : files->getFiles())
			{
				int fileId = file->getFileId();

				int widgetId = (archiveId << 16) + fileId;

				std::shared_ptr<InterfaceDefinition> iface = loader->load(widgetId, file->getContents());
				ifaces[fileId] = iface;
			}
		}
	}

	int InterfaceManager::getNumInterfaceGroups()
	{
		return interfaces.size();
	}

	int InterfaceManager::getNumChildren(int groupId)
	{
		return interfaces[groupId].length;
	}

	std::vector<std::shared_ptr<InterfaceDefinition>> InterfaceManager::getIntefaceGroup(int groupId)
	{
		return interfaces[groupId];
	}

	std::shared_ptr<InterfaceDefinition> InterfaceManager::getInterface(int groupId, int childId)
	{
		return interfaces[groupId][childId];
	}

	std::vector<std::vector<std::shared_ptr<InterfaceDefinition>>> InterfaceManager::getInterfaces()
	{
		return interfaces;
	}

	void InterfaceManager::export_Keyword(std::shared_ptr<File> out)
	{
		out->mkdirs();

		for (auto defs : interfaces)
		{
			if (defs.empty())
			{
				continue;
			}

			for (auto def : defs)
			{
				if (def == nullptr)
				{
					continue;
				}

				std::shared_ptr<InterfaceExporter> exporter = std::make_shared<InterfaceExporter>(def);

				std::shared_ptr<File> folder = std::make_shared<File>(out, L"" + std::to_wstring(static_cast<int>(static_cast<unsigned int>(def->id) >> 16)));
				folder->mkdirs();

				std::shared_ptr<File> targ = std::make_shared<File>(folder, std::to_wstring(def->id & 0xffff) + L".json");
				exporter->exportTo(targ);
			}
		}
	}

	void InterfaceManager::java(std::shared_ptr<File> java)
	{
		System::setProperty(L"line.separator", L"\n");
		java->mkdirs();
		std::shared_ptr < java->io.File > targ = std::make_shared < java->io.File > (java, L"InterfaceID.java");
//JAVA TO C++ CONVERTER NOTE: The following 'try with resources' block is replaced by its C++ equivalent:
//ORIGINAL LINE: try (java.io.PrintWriter fw = new java.io.PrintWriter(targ))
		{
			java->io.PrintWriter fw = java->io.PrintWriter(targ);
			fw.println(L"/* This file is automatically generated. Do not edit. */");
			fw.println(L"package net.runelite.api;");
			fw.println(L"");
			fw.println(L"public final class InterfaceID {");
			for (auto defs : interfaces)
			{
				if (defs.empty())
				{
					continue;
				}
				for (auto def : defs)
				{
//JAVA TO C++ CONVERTER TODO TASK: The following Java case-insensitive String method call is not converted:
					if (def == nullptr || def->name == L"" || def->name.equalsIgnoreCase(L"NULL"))
					{
						continue;
					}

					std::wstring name = namer->name(def->name, def->id);
					if (name == L"")
					{
						continue;
					}

					fw.println(L"	public static final int " + name + L" = " + std::to_wstring(def->id) + L";");
				}
			}
			fw.println(L"}");
		}
	}
}
